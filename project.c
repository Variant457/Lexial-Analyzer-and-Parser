/*
CS 382 Project: Lexical Analyzer and Parser

BNF Grammar:
    <id> --> A | B | C
    <expr> --> <expr> + <term>
        | <expr> - <term>
        | <term>
    <term> --> <term> * <factor>
        | <term> / <factor>
        | <factor>
    <factor> --> (<expr>)
        | <id>
*/


/*
The lexical analyzer will get the expression from the input file and read each character to determine the token for each lexeme. 
The following tokens are defined as:
    '(' --> LEFT_PAREN
    ')' --> RIGHT_PAREN
    '*' --> MULT_OP
    '/' --> DIV_OP
    '+' --> ADD_OP
    '-' --> SUB_OP
    All Integers --> INT_LIT
    All Variables --> IDENT

In order to determine whether a lexeme has a INT_LIT or IDENT token, all alphanumeric characters are parsed to determine
which token it is:
    All Letters --> LETTER
    All Integers --> DIGIT
    All Other Characters --> UNKNOWN

The lexical analyzer will know if the lexeme is an integer if there are only DIGITs in the substring
and it can determine if there's a variable if a substring starts with a LETTER and only contains LETTERs and DIGITs.
All other characters are marked as UNKNOWN which checks if the character is any of the tokens listed above. 


The Parser is defined by the following Extended BNF Grammar:
    <expr> --> <term> {(+ | -) <term>}
    <term> --> <factor> {(* | /) <factor>}
    <factor> --> id | int_constant | (<expr>)
*/

#include <stdio.h>
#include <ctype.h>

int charClass;
char nextChar;
char lexeme[100];
int lexLen;
int token;
int nextToken;
FILE *in_fp, *lex_out, *parse_out;

// Lexical functions
int lex();
void getChar();
void addChar();
void getNonBlank();

// Parse functions
void expr();
void term();
void factor();

// Token Codes
#define INT_LIT 10
#define IDENT 11
#define ADD_OP 20
#define SUB_OP 21
#define MULT_OP 22
#define DIV_OP 23
#define LEFT_PAREN 30
#define RIGHT_PAREN 31

#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

void main() {
    if((in_fp = fopen("input.in", "r")) == NULL) printf("ERROR - Cannot open input.in\n");
    else {
        // Opens Output Files
        lex_out = fopen("Lexical Output.txt", "w");
        parse_out = fopen("Parser Output.txt", "w");

        // Starts lexical analyzer
        getChar();
        lex();
        if(nextToken != EOF) expr(0);

        // Closes Files
        fclose(in_fp);
        fclose(lex_out);
        fclose(parse_out);
    }
}

int lookup(char ch){
    switch(ch){
        case '(':
            nextToken = LEFT_PAREN;
            break;
        case ')':
            nextToken = RIGHT_PAREN;
            break;
        case '*':
            nextToken = MULT_OP;
            break;
        case '/':
            nextToken = DIV_OP;
            break;
        case '+':
            nextToken = ADD_OP;
            break;
        case '-':
            nextToken = SUB_OP;
            break;
        default:
            nextToken = EOF;
            break;
    }

    addChar();
    return nextToken;
}

void getNonBlank(){
    while(isspace(nextChar)) getChar();
}

void getChar(){
    if((nextChar = getc(in_fp)) != EOF){
        if(isalpha(nextChar)) charClass = LETTER;
        else if(isdigit(nextChar)) charClass = DIGIT;
        else charClass = UNKNOWN;
    } else charClass = EOF;
}

void addChar(){
    if(lexLen <= 98){
        lexeme[lexLen++] = nextChar;
        lexeme[lexLen] = 0;
    } else {
        printf("ERROR - Lexeme is too long\n");
    }
}

int lex(){
    lexLen = 0;
    getNonBlank();
    switch(charClass){
        case LETTER:
            addChar();
            getChar();
            while(charClass == LETTER || charClass == DIGIT){
                addChar();
                getChar();
            }
            nextToken = IDENT;
            break; 
        case DIGIT:
            addChar();
            getChar();
            while(charClass == DIGIT){
                addChar();
                getChar();
            }
            nextToken = INT_LIT;
            break;
        case UNKNOWN:
            lookup(nextChar);
            getChar();
            break;
        case EOF:
            nextToken = EOF;
            lexeme[0] = 'E';
            lexeme[1] = 'O';
            lexeme[2] = 'F';
            lexeme[3] = 0;
            break;
    }

    printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
    fprintf(lex_out, "Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);

    return nextToken;
}

void ind(int indent){
    for (int i = 0; i < indent; i++){
        printf("\t");
        fprintf(parse_out, "\t");
    }
}

/* Parses strings in the language generated by the EBNF rule:
    <expr> --> <term> {(+ | -) <term>}
*/
void expr(int indent){
    ind(indent);
    printf("[expr\n");
    fprintf(parse_out, "[expr\n");
    term(indent + 1);
    while(nextToken == ADD_OP || nextToken == SUB_OP){
        ind(indent + 1);
        printf("[%s]\n", lexeme);
        fprintf(parse_out, "[%s]\n", lexeme);
        lex();
        term(indent + 1);
    }

    ind(indent);
    printf("]\n");
    fprintf(parse_out, "]\n");
}

/*
Parses strings in the language generated by the EBNF rule:
    <term> --> <factor> {(* | /) <factor>}
*/
void term(int indent){
    ind(indent);
    printf("[term\n");
    fprintf(parse_out, "[term\n");
    factor(indent + 1);
    while(nextToken == MULT_OP || nextToken == DIV_OP){
        ind(indent + 1);
        printf("[%s]\n", lexeme);
        fprintf(parse_out, "[%s]\n", lexeme);
        lex();
        factor(indent + 1);
    }

    ind(indent);
    printf("]\n");
    fprintf(parse_out, "]\n");
}

/*
Parses strings in the language generated by the EBNF rule:
    <factor> --> id | int_constant | (<expr>)
*/
void factor(int indent){
    ind(indent);
    printf("[factor\n");
    fprintf(parse_out, "[factor\n");
    if(nextToken == IDENT || nextToken == INT_LIT){
        ind(indent + 1);
        printf("[%s [%s]]\n", (nextToken == IDENT) ? "id" : "int_constant", lexeme);
        fprintf(parse_out, "[%s [%s]]\n", (nextToken == IDENT) ? "id" : "int_constant", lexeme);
        lex();
    } else {
        if(nextToken == LEFT_PAREN){
            ind(indent + 1);
            printf("[(]\n");
            fprintf(parse_out, "[(]\n");
            lex();
            expr(indent + 1);
            if(nextToken == RIGHT_PAREN){
                ind(indent + 1);
                printf("[)]\n");
                fprintf(parse_out, "[)]\n");
                lex();
            }
        }
    }

    ind(indent);
    printf("]\n");
    fprintf(parse_out, "]\n");
}